{% extends 'base.html' %}
{% block content %}
<h2 class="mb-4 animate__animated animate__fadeIn">Interactive Target for Round #{{ round_id }}</h2>

<form method="POST">
    <!-- We'll store hits as JSON in a hidden field -->
    <input type="hidden" id="hits_json" name="hits_json" />

    <div class="mb-3">
        <label for="total_shots" class="form-label">Total Shots (including misses)</label>
        <input 
            type="number" 
            class="form-control" 
            name="total_shots" 
            id="total_shots"
            value="{{ total_shots }}"
        />
    </div>

    <div style="text-align: center;">
        <!-- Canvas for the target -->
        <canvas id="targetCanvas" width="400" height="400" style="border:1px solid #666;"></canvas>
    </div>

    <!-- Undo/Redo buttons -->
    <div class="mt-2 text-center">
        <button type="button" id="undoBtn" class="btn btn-sm btn-danger">Undo</button>
        <button type="button" id="redoBtn" class="btn btn-sm btn-secondary">Redo</button>
    </div>

    <button type="submit" class="btn btn-custom mt-3">Save Shots</button>
</form>

<script>
// We'll store all hits in this array, and store undone hits in another for redo.
let hits = JSON.parse('{{ hits|tojson|safe }}') || [];
let undone = []; // for "redo" functionality

const canvas = document.getElementById('targetCanvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;
const centerX = width / 2;
const centerY = height / 2;

/*
  We have five concentric rings for scores 10 -> 6 at radii [40, 70, 100, 130, 160].
  We want the center (radius=40) to be white and the outer ring (radius=160) also white,
  with black/white alternation in between. We'll draw from the largest radius down to
  the smallest, each ring covering the previous.
*/
const ringRadii = [160, 130, 100, 70, 40];

// Draw the target: dark background, then rings from largest to smallest
function drawTarget() {
    // Fill the entire canvas background with a dark color
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, width, height);

    // We'll alternate ring colors: false => white, true => black.
    let colorFlag = false; // so the largest ring is white
    for (let i = 0; i < ringRadii.length; i++) {
        ctx.beginPath();
        ctx.arc(centerX, centerY, ringRadii[i], 0, 2 * Math.PI);
        ctx.fillStyle = colorFlag ? '#000000' : '#ffffff';
        ctx.fill();
        // Flip the color for the next ring
        colorFlag = !colorFlag;
    }

    // Optional crosshair lines
    ctx.strokeStyle = '#888';
    ctx.beginPath();
    ctx.moveTo(centerX, 0);
    ctx.lineTo(centerX, height);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(0, centerY);
    ctx.lineTo(width, centerY);
    ctx.stroke();

    // Draw existing hits
    ctx.fillStyle = '#f00';
    hits.forEach((hit) => {
        ctx.beginPath();
        ctx.arc(hit.x, hit.y, 5, 0, 2 * Math.PI);
        ctx.fill();
    });
}
drawTarget();

// Whenever we click on the canvas, we add a shot
canvas.addEventListener('click', (evt) => {
    const rect = canvas.getBoundingClientRect();
    const x = evt.clientX - rect.left;
    const y = evt.clientY - rect.top;

    hits.push({ x, y });
    // Once we add a new shot, we clear the undone array so we can't redo older states
    undone = [];
    drawTarget();
});

// Undo button: remove the last shot (if any)
document.getElementById('undoBtn').addEventListener('click', () => {
    if (hits.length > 0) {
        undone.push(hits.pop());
        drawTarget();
    }
});

// Redo button: restore the last undone shot (if any)
document.getElementById('redoBtn').addEventListener('click', () => {
    if (undone.length > 0) {
        hits.push(undone.pop());
        drawTarget();
    }
});

// On form submit, store hits in hidden field
document.querySelector('form').addEventListener('submit', () => {
    const hitsField = document.getElementById('hits_json');
    hitsField.value = JSON.stringify(hits);
});
</script>
{% endblock %}